<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Tex(t Se)cret demo</title>
<style>
  body {
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    max-width: 700px;
    margin: 3rem auto;
  }

  button {
    padding: .6rem 1rem;
    margin-right: .5rem;
  }

  #log {
    white-space: pre-wrap;
    background: #f6f6f8;
    padding: 1rem;
    border-radius: 8px;
  }
</style>
<h2>Tex(t Se)cret demo</h2>
<p>Register writes a secret into the key‚Äôs largeBlob; Authenticate reads it and decrypts.</p>

<p><button id="register">Register key + store secret</button></p>
<p><button id="authenticate">Authenticate + read secret</button></p>
<p><button id="fake">Fake secret</button></p>
<p><button id="encrypt">Encrypt sample text (with stored secret)</button></p>
<p><button id="decrypt">Decrypt sample text</button></p>

<p><span id="authState" class="muted">(secret: not loaded)</span></p>

<div class="inputs">
  <p>
    <label for="pt">Plaintext:</label>
  </p>
  <p>
    <textarea name="pt" id="pt" value="" rows="3" cols="60">hello from the sea üê¨</textarea>
  </p>
  <p>
    <label for="ct">Ciphertext (base64):</label>
  </p>
  <p>
    <textarea name="ct" id="ct" value="" rows="3" cols="60"></textarea>
  </p>
</div>

<div id="log"></div>

<script>
  const $ = sel => document.querySelector(sel);
  const log = (...a) => { $('#log').textContent += a.join(' ') + "\n"; };
  const enc = new TextEncoder(), dec = new TextDecoder();
  const b64 = ab => btoa(String.fromCharCode(...new Uint8Array(ab)));
  const ubuf = b64s => Uint8Array.from(atob(b64s), c => c.charCodeAt(0)).buffer;
  function be16(n) { return new Uint8Array([(n >>> 8) & 0xff, n & 0xff]); }
  function readBE16(u8, off) { return (u8[off] << 8) | u8[off + 1]; }
  function randBytes(n) { const a = new Uint8Array(n); crypto.getRandomValues(a); return a; }

  // let credentialIdB64 = localStorage.getItem('credIdB64') || null;
  let secretB64 = null; // loaded from largeBlob on authenticate

  // ---- WebAuthn helpers
  const rp = { id: location.hostname, name: "Demo RP" };
  const user = { id: randBytes(16), name: "jay@mac.home", displayName: "Jay" };

  // ---- Registration: create credential AND write largeBlob (32-byte secret)
  async function doRegister() {
    // see https://github.com/w3c/webauthn/wiki/Explainer:-WebAuthn-Large-Blob-Extension

    const cred = await navigator.credentials.create({
      publicKey: {
        challenge: randBytes(32),
        rp,
        user,
        pubKeyCredParams: [{ type: "public-key", alg: -7 }], // ES256
        authenticatorSelection: {
          // authenticatorAttachment: "platform",   // <- Limiting to only passkey on iOS
          residentKey: "preferred",
          userVerification: "preferred",
        },
        timeout: 60000,
        attestation: "none",
        extensions: {
          largeBlob: { support: "required" }
        }
      }
    });

    credentialIdB64 = b64(cred.rawId);
    // localStorage.setItem('credIdB64', credentialIdB64);
    log("‚úÖ Registered credential. ID:", credentialIdB64);

    if (!cred.getClientExtensionResults().largeBlob) {
      log("‚ùå Large blob not supported by the user agent.");
      return;
    } else {
      log("‚úÖ  Large blob is supported by the user agent.");
    }

    try {
      const secret = randBytes(32); // store this in largeBlob
      const assertion = await navigator.credentials.get({
        publicKey: {
          challenge: randBytes(32),
          // allowCredentials: [{
          //   type: "public-key",
          //   id: ubuf(credentialIdB64),
          //   //transports: ["nfc", "usb", "ble"] // <-- Limiting to Yubikey only
          // }],
          userVerification: "preferred",
          timeout: 60000,
          extensions: {
            largeBlob: { write: new Uint8Array(secret) }
          }
        }
      });

      if (assertion.getClientExtensionResults().largeBlob.written) {
        // keep a copy of the plaintext secret OUTSIDE only for demo encryption now;
        // in a real app, you could also encrypt data right after create() and store ciphertext server-side.
        secretB64 = b64(secret);
        $("#authState").textContent = "secret: loaded (from registration)";
        $("#authState").className = "ok";
        log("üîê Secret (32B) written to largeBlob.");
      } else {
        // The large blob could not be written (e.g. because of a lack of space).
        // The assertion is still valid.
        log("‚ùå The large blob could not be written");
      }
    } catch (e) { log("‚ùå Secret store failed:", e.message); console.error(e); }
  }

  // ---- Authentication: get assertion AND read largeBlob back
  async function doAuthenticate() {
    // if (!credentialIdB64) { return log("‚ö†Ô∏è No credential; register first."); }

    const publicKey = {
      challenge: randBytes(32),
      // allowCredentials: [{
      //   type: "public-key",
      //   id: ubuf(credentialIdB64),
      //   // transports: ["nfc", "usb", "ble"] // <-- Limiting to Yubikey only
      // }],
      userVerification: "preferred",
      timeout: 60000,
      // Ask to read the largeBlob
      extensions: { largeBlob: { read: true } }
    };

    try {
      const assertion = await navigator.credentials.get({ publicKey });
      const clientExt = assertion.getClientExtensionResults();
      if (clientExt && clientExt.largeBlob && clientExt.largeBlob.blob) {
        secretB64 = b64(clientExt.largeBlob.blob); // ArrayBuffer -> b64
        $("#authState").textContent = "secret: loaded (from authentication)";
        $("#authState").className = "ok";
        log("‚úÖ Authenticated. Read secret from largeBlob (" + (clientExt.largeBlob.blob.byteLength) + " bytes).");
      } else {
        log("‚ö†Ô∏è Auth OK but largeBlob read not returned (not supported or not present).");
      }
    } catch (e) { log("‚ùå Authentication failed:", e.message); console.error(e); }
  }

  // ---- Fake: generate random secret (not stored anywhere)
  async function doFake() {
    const secret = randBytes(32); // store this in largeBlob

    secretB64 = b64(secret); // ArrayBuffer -> b64
    $("#authState").textContent = "secret: loaded (fake)";
    $("#authState").className = "ok";
    log("‚úÖ Faked secret (" + (secret.byteLength) + " bytes) " + secretB64);
  }

  /* ===== Key derivation (HKDF-SHA256) from largeBlob secret ===== */
  async function deriveAesKey(secretRaw, salt) {
    const ikm = await crypto.subtle.importKey("raw", secretRaw, "HKDF", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      { name: "HKDF", hash: "SHA-256", salt, info: enc.encode("YK-largeBlob-text") },
      ikm,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }

  /* ===== File format =====
  * Header:
  *   0..5    : ASCII "YKLB1\0" (6 bytes, NUL terminator)
  *   6..21   : salt (16 bytes)
  *   22..33  : iv (12 bytes)
  *   34..35  : nameLen (uint16 BE)
  *   36..(36+nameLen-1): filename UTF-8
  *   ...     : ciphertext (AES-GCM)
  */
  const MAGIC = new Uint8Array([0x59, 0x4b, 0x4c, 0x42, 0x31, 0x00]); // "YKLB1\0"

  function makeHeader(salt, iv, name) {
    const nameUtf8 = enc.encode(name);
    const nameLen = nameUtf8.length;
    const head = new Uint8Array(36 + nameLen);
    head.set(MAGIC, 0);
    head.set(salt, 6);
    head.set(iv, 22);
    head.set(be16(nameLen), 34);
    head.set(nameUtf8, 36);
    return head;
  }

  function parseHeader(u8) {
    for (let i = 0; i < 6; i++) { if (u8[i] !== MAGIC[i]) throw new Error("Bad magic / not a YKLB1 file"); }
    const salt = u8.slice(6, 22);
    const iv = u8.slice(22, 34);
    const nameLen = readBE16(u8, 34);
    const nameBytes = u8.slice(36, 36 + nameLen);
    const name = dec.decode(nameBytes);
    const bodyOffset = 36 + nameLen;
    return { salt, iv, name, bodyOffset };
  }

  // ---- WebCrypto AES-GCM using the secret as raw key
  async function importKeyFromSecretB64() {
    if (!secretB64) throw new Error("No secret loaded. Authenticate first.");
    const key = await crypto.subtle.importKey(
      "raw", ubuf(secretB64), { name: "AES-GCM" }, false, ["encrypt", "decrypt"]
    );
    return key;
  }

  $('#encrypt').onclick = async () => {
    try {
      const name = "some file name";
      const secretRaw = ubuf(secretB64);
      const salt = randBytes(16);
      const iv = randBytes(12);
      log("salt: ", b64(salt.buffer));
      log("iv: ", b64(iv.buffer));
      log("name: ", name);
      const key = await deriveAesKey(secretRaw, salt);
      const pt = enc.encode($('#pt').value);
      const ct = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, pt));
      const header = makeHeader(salt, iv, name);

      const out = new Uint8Array(header.length + ct.length);
      out.set(header, 0);
      out.set(ct, header.length);

      $('#ct').value = b64(out.buffer);
      log("üîí Encrypted with largeBlob secret.");
    } catch (e) { log("‚ùå Encrypt error:", e.message); }
  };

  $('#decrypt').onclick = async () => {
    try {
      const secretRaw = ubuf(secretB64);
      const data = new Uint8Array(ubuf($('#ct').value));
      const { salt, iv, name, bodyOffset } = parseHeader(data);
      log("salt: ", b64(salt));
      log("iv: ", b64(iv));
      log("name: ", name);
      const key = await deriveAesKey(secretRaw, salt);
      const ct = data.slice(bodyOffset);
      const ptBuf = new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct));
      const pt = dec.decode(ptBuf);
      log("üîì Decrypted file name:", name);
      log("üîì Decrypted plaintext:", pt);
      $('#pt').value = pt;
    } catch (e) { log("‚ùå Decrypt error:", e.message); }
  };

  $('#register').onclick = doRegister;
  $('#authenticate').onclick = doAuthenticate;
  $('#fake').onclick = doFake;
</script>

</html>