<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Tex(t Se)cret demo</title>
<style>
  body {
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    max-width: 700px;
    margin: 3rem auto;
  }

  button {
    padding: .6rem 1rem;
    margin-right: .5rem;
  }

  #log {
    white-space: pre-wrap;
    background: #f6f6f8;
    padding: 1rem;
    border-radius: 8px;
  }
</style>
<h2>Tex(t Se)cret demo</h2>
<p>Register writes a secret into the key‚Äôs largeBlob; Authenticate reads it and decrypts.</p>

<p><button id="register">Register key + store secret</button></p>
<p><button id="authenticate">Authenticate + read secret</button></p>
<p><button id="fake">Fake secret</button>&nbsp;<button id="shuffle">Shuffle secrets</button></p>
<p><button id="encrypt">Encrypt sample text (with stored secret)</button></p>
<p><button id="decrypt">Decrypt sample text</button></p>

<p><span id="authState" class="muted">(secret not loaded)</span></p>

<div class="inputs">
  <p>
    <label for="pt">Plaintext:</label>
  </p>
  <p>
    <textarea name="pt" id="pt" value="" rows="3" cols="60">hello from the sea üê¨</textarea>
  </p>
  <p>
    <label for="ct">Ciphertext (base64):</label>
  </p>
  <p>
    <textarea name="ct" id="ct" value="" rows="6" cols="60"></textarea>
  </p>
</div>

<div id="log"></div>

<script>
  const $ = sel => document.querySelector(sel);
  const log = (...a) => { $('#log').textContent += a.join(' ') + "\n"; };
  const enc = new TextEncoder(), dec = new TextDecoder();
  const b64 = ab => btoa(String.fromCharCode(...new Uint8Array(ab)));
  const ubuf = b64s => Uint8Array.from(atob(b64s), c => c.charCodeAt(0)).buffer;
  function be16(n) { return new Uint8Array([(n >>> 8) & 0xff, n & 0xff]); }
  function readBE16(u8, off) { return (u8[off] << 8) | u8[off + 1]; }
  function randBytes(n) { const a = new Uint8Array(n); crypto.getRandomValues(a); return a; }

  // let credentialIdB64 = localStorage.getItem('credIdB64') || null;
  let secretsB64 = []; // loaded from largeBlob on authenticate

  // ---- WebAuthn helpers
  const rp = { id: location.hostname, name: "Demo RP" };
  const user = { id: randBytes(16), name: "jay@mac.home", displayName: "Jay" };

  // ---- Registration: create credential AND write largeBlob (32-byte secret)
  async function doRegister() {
    // see https://github.com/w3c/webauthn/wiki/Explainer:-WebAuthn-Large-Blob-Extension

    const cred = await navigator.credentials.create({
      publicKey: {
        challenge: randBytes(32),
        rp,
        user,
        pubKeyCredParams: [{ type: "public-key", alg: -7 }], // ES256
        authenticatorSelection: {
          // authenticatorAttachment: "platform",   // <- Limiting to only passkey on iOS
          residentKey: "preferred",
          userVerification: "preferred",
        },
        timeout: 60000,
        attestation: "none",
        extensions: {
          largeBlob: { support: "required" }
        }
      }
    });

    credentialIdB64 = b64(cred.rawId);
    // localStorage.setItem('credIdB64', credentialIdB64);
    log("‚úÖ Registered credential. ID:", credentialIdB64);

    if (!cred.getClientExtensionResults().largeBlob) {
      log("‚ùå Large blob not supported by the user agent.");
      return;
    } else {
      log("‚úÖ  Large blob is supported by the user agent.");
    }

    try {
      const secret = randBytes(32); // store this in largeBlob
      const assertion = await navigator.credentials.get({
        publicKey: {
          challenge: randBytes(32),
          // allowCredentials: [{
          //   type: "public-key",
          //   id: ubuf(credentialIdB64),
          //   //transports: ["nfc", "usb", "ble"] // <-- Limiting to Yubikey only
          // }],
          userVerification: "preferred",
          timeout: 60000,
          extensions: {
            largeBlob: { write: new Uint8Array(secret) }
          }
        }
      });

      if (assertion.getClientExtensionResults().largeBlob.written) {
        // keep a copy of the plaintext secret OUTSIDE only for demo encryption now;
        // in a real app, you could also encrypt data right after create() and store ciphertext server-side.
        secretsB64.push(b64(secret));
        $("#authState").textContent = "" + (Object.keys(secretsB64).length) + " secret(s): loaded (last from registration)";
        $("#authState").className = "ok";
        log("üîê Secret (32B) written to largeBlob.");
      } else {
        // The large blob could not be written (e.g. because of a lack of space).
        // The assertion is still valid.
        log("‚ùå The large blob could not be written");
      }
    } catch (e) { log("‚ùå Secret store failed:", e.message); console.error(e); }
  }

  // ---- Authentication: get assertion AND read largeBlob back
  async function doAuthenticate() {
    // if (!credentialIdB64) { return log("‚ö†Ô∏è No credential; register first."); }

    const publicKey = {
      challenge: randBytes(32),
      // allowCredentials: [{
      //   type: "public-key",
      //   id: ubuf(credentialIdB64),
      //   // transports: ["nfc", "usb", "ble"] // <-- Limiting to Yubikey only
      // }],
      userVerification: "preferred",
      timeout: 60000,
      // Ask to read the largeBlob
      extensions: { largeBlob: { read: true } }
    };

    try {
      const assertion = await navigator.credentials.get({ publicKey });
      const clientExt = assertion.getClientExtensionResults();
      if (clientExt && clientExt.largeBlob && clientExt.largeBlob.blob) {
        secretsB64.push(b64(clientExt.largeBlob.blob)); // ArrayBuffer -> b64
        $("#authState").textContent = "" + (Object.keys(secretsB64).length) + " secret(s): loaded (last from authentication)";
        $("#authState").className = "ok";
        log("‚úÖ Authenticated. Read secret from largeBlob (" + (clientExt.largeBlob.blob.byteLength) + " bytes).");
      } else {
        log("‚ö†Ô∏è Auth OK but largeBlob read not returned (not supported or not present).");
      }
    } catch (e) { log("‚ùå Authentication failed:", e.message); console.error(e); }
  }

  // ---- Fake: generate random secret (not stored anywhere)
  async function doFake() {
    const secret = randBytes(32); // store this in largeBlob
    const secretId = randBytes(8); // store this in largeBlob

    const secretB64 = b64(secret); // ArrayBuffer -> b64
    secretsB64.push(secretB64);
    $("#authState").textContent = "" + (Object.keys(secretsB64).length) + " secret(s): loaded (last fake)";
    $("#authState").className = "ok";
    log("‚úÖ Faked secret (" + (secret.byteLength) + " bytes) " + secretB64);
  }

  /* ===== Key derivation (HKDF-SHA256) from largeBlob secret ===== */
  async function deriveAesKey(secretRaw, salt) {
    const ikm = await crypto.subtle.importKey("raw", secretRaw, "HKDF", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      { name: "HKDF", hash: "SHA-256", salt, info: enc.encode("YK-largeBlob-text") },
      ikm,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }

  /* ====== Header v2 (multiple recipients) ======
   * MAGIC: "YKLB2\0" (6 bytes)
   * 0..5     : MAGIC
   * 6..17    : dataIv (12 bytes)   // IV used to encrypt the plaintext
   * 18..19   : nameLen (uint16 BE)
   * 20..(20+nameLen-1): filename UTF-8
   * next 2   : recipCount (uint16 BE)
   * Then for each recipient i in [0..recipCount-1]:
   *   salt (16 bytes)              // HKDF salt for this recipient
   *   wrapIv (12 bytes)            // AES-GCM IV for wrapping the data key
   *   wrapLen (uint16 BE)          // length of wrappedKey bytes
   *   wrappedKey (wrapLen bytes)   // AES-GCM( derivedKey ; dataKeyRaw )
   * After recipients block:
   *   ciphertext (AES-GCM over plaintext using dataKey & dataIv)
   */
  const MAGIC2 = new Uint8Array([0x59, 0x4b, 0x4c, 0x42, 0x32, 0x00]); // "YKLB2\0"

  /* ---- build header (without ciphertext) ---- */
  function makeHeaderV2(dataIv, name, recipEntries) {
    const nameUtf8 = enc.encode(name);
    const nameLen = nameUtf8.length;

    // Compute total size
    let size = 6 + 12 + 2 + nameLen + 2; // magic + dataIv + nameLen + name + recipCount
    for (const r of recipEntries) {
      size += 16 + 12 + 2 + r.wrappedKey.length; // salt + wrapIv + wrapLen + wrappedKey
    }

    const head = new Uint8Array(size);
    let off = 0;

    head.set(MAGIC2, off); off += 6;
    head.set(dataIv, off); off += 12;
    head.set(be16(nameLen), off); off += 2;
    head.set(nameUtf8, off); off += nameLen;

    head.set(be16(recipEntries.length), off); off += 2;

    for (const r of recipEntries) {
      head.set(r.salt, off); off += 16;
      head.set(r.wrapIv, off); off += 12;
      head.set(be16(r.wrappedKey.length), off); off += 2;
      head.set(r.wrappedKey, off); off += r.wrappedKey.length;
    }
    return head;
  }

  /* ---- parse header (returns meta + offset to ciphertext) ---- */
  function parseHeaderV2(u8) {
    for (let i = 0; i < 6; i++) {
      if (u8[i] !== MAGIC2[i]) throw new Error("Bad magic / not a YKLB2 file");
    }
    let off = 6;
    const dataIv = u8.slice(off, off + 12); off += 12;

    const nameLen = readBE16(u8, off); off += 2;
    const nameBytes = u8.slice(off, off + nameLen); off += nameLen;
    const name = dec.decode(nameBytes);

    const recipCount = readBE16(u8, off); off += 2;
    const recipients = [];
    for (let i = 0; i < recipCount; i++) {
      const salt = u8.slice(off, off + 16); off += 16;
      const wrapIv = u8.slice(off, off + 12); off += 12;
      const wrapLen = readBE16(u8, off); off += 2;
      const wrappedKey = u8.slice(off, off + wrapLen); off += wrapLen;
      recipients.push({ salt, wrapIv, wrappedKey });
    }

    return { dataIv, name, recipients, bodyOffset: off };
  }

  /* ====== Encrypt flow ====== */
  async function doEncrypt() {
    try {
      // 1) Generate a fresh AES-GCM-256 data key for the plaintext
      const dataKey = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
      /* extractable */ true,
        ["encrypt", "decrypt"]
      );
      const dataKeyRaw = new Uint8Array(await crypto.subtle.exportKey("raw", dataKey)); // 32 bytes

      const name = "some file name";
      const pt = enc.encode($('#pt').value);
      const dataIv = randBytes(12);

      // 2) Encrypt plaintext with data key
      const ct = new Uint8Array(
        await crypto.subtle.encrypt({ name: "AES-GCM", iv: dataIv }, dataKey, pt)
      );

      // 3) For each secret, derive key and wrap dataKeyRaw via AES-GCM
      const recipEntries = [];
      for (const secretB64 of secretsB64) {
        const secretRaw = ubuf(secretB64);
        const salt = randBytes(16);
        const wrapIv = randBytes(12);
        const wrapKey = await deriveAesKey(secretRaw, salt);
        const wrappedKey = new Uint8Array(
          await crypto.subtle.encrypt({ name: "AES-GCM", iv: wrapIv }, wrapKey, dataKeyRaw)
        );
        recipEntries.push({ salt, wrapIv, wrappedKey });
      }

      // 4) Build header + output
      const header = makeHeaderV2(dataIv, name, recipEntries);
      const out = new Uint8Array(header.length + ct.length);
      out.set(header, 0);
      out.set(ct, header.length);

      $('#ct').value = b64(out.buffer);
      log("üîí Encrypted with a fresh data key and wrapped for", recipEntries.length, "recipient(s).");
      log("iv (data): ", b64(dataIv.buffer));
      log("name: ", name);
    } catch (e) {
      log("‚ùå Encrypt error:", e.message);
    }
  }

  /* ====== Decrypt flow (tries all secrets & recipients) ====== */
  async function doDecrypt() {
    try {
      const data = new Uint8Array(ubuf($('#ct').value));
      const { dataIv, name, recipients, bodyOffset } = parseHeaderV2(data);
      const ct = data.slice(bodyOffset);

      log("name: ", name);
      log("recipients in header: ", recipients.length);

      // Try to unwrap the data key using each provided secret against each recipient entry
      let dataKey = null;

      outer:
      for (const secretB64 of secretsB64) {
        const secretRaw = ubuf(secretB64);

        for (const r of recipients) {
          try {
            const wrapKey = await deriveAesKey(secretRaw, r.salt);
            const dataKeyRaw = new Uint8Array(
              await crypto.subtle.decrypt({ name: "AES-GCM", iv: r.wrapIv }, wrapKey, r.wrappedKey)
            );
            dataKey = await crypto.subtle.importKey(
              "raw",
              dataKeyRaw,
              { name: "AES-GCM" },
              false,
              ["decrypt"]
            );
            log("‚úÖ Unwrapped data key with one of your secrets.");
            break outer; // success
          } catch (_) {
            log("üîÅ Wrong secret for this recipient; keep trying.")
          }
        }
      }

      if (!dataKey) {
        throw new Error("None of the provided secrets could unwrap the data key.");
      }

      // Decrypt the payload
      const ptBuf = new Uint8Array(
        await crypto.subtle.decrypt({ name: "AES-GCM", iv: dataIv }, dataKey, ct)
      );
      const pt = dec.decode(ptBuf);

      log("üîì Decrypted file name:", name);
      log("üîì Decrypted plaintext:", pt);
      $('#pt').value = pt;
    } catch (e) {
      log("‚ùå Decrypt error:", e.message);
    }
  };

  /* ======= shuffle array https://en.wikipedia.org/wiki/Fisher‚ÄìYates_shuffle ====== */
  function shuffle(array) {

    let currentIndex = array.length;

    // While there remain elements to shuffle...
    while (currentIndex != 0) {

      // Pick a remaining element...
      let randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;

      // And swap it with the current element.
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
  }

  $('#decrypt').onclick = doDecrypt;
  $('#encrypt').onclick = doEncrypt;
  $('#register').onclick = doRegister;
  $('#authenticate').onclick = doAuthenticate;
  $('#fake').onclick = doFake;
  $('#shuffle').onclick = () => {
    shuffle(secretsB64);
  };
</script>

</html>